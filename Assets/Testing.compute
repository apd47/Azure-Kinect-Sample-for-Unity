// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> ColorTex;
Texture2D<float4> DepthTex;

Texture2D<float4> oldDepthTexture;
RWTexture3D<float4> Result;

SamplerState _PointClamp, _PointRepeat;

float _Size;

int minDepth;
int maxDepth;

[numthreads(16, 16, 1)]
void CSMain(uint2 id : SV_DispatchThreadID)
{
	float2 uv = float2((float)id.x / _Size, (float)id.y / _Size);

	half4 col = ColorTex.SampleLevel(_PointClamp, uv, 0);
	uint depth = DepthTex.SampleLevel(_PointClamp, uv, 0).r * 65536;
	uint oldDepth = oldDepthTexture.SampleLevel(_PointClamp, uv.xy, 0).r * 65536;

	float stepSize = ((float)(maxDepth - minDepth) / _Size);

	if (oldDepth > minDepth && oldDepth < maxDepth) {
		int oldDepthIndex = (oldDepth - minDepth) / stepSize;
		uint3 oldIndex = uint3(_Size - id.x, _Size - id.y, oldDepthIndex);
		Result[oldIndex] = float4(0, 0, 0, 0);
	}

	if (depth<minDepth || depth>maxDepth) {
		Result[id] = 0;
	}
	else {
		int depthIndex = (depth - minDepth) / stepSize;
		uint3 index = uint3(_Size-id.x, _Size-id.y, depthIndex);
		Result[index] = float4(col.rgb, 1);
	}
}
